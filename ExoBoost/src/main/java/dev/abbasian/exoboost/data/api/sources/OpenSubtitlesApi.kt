package dev.abbasian.exoboost.data.api.sources

import dev.abbasian.exoboost.domain.model.SubtitleFormat
import dev.abbasian.exoboost.domain.model.SubtitleQuery
import dev.abbasian.exoboost.domain.model.SubtitleSource
import dev.abbasian.exoboost.domain.model.SubtitleTrack
import dev.abbasian.exoboost.util.ExoBoostLogger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject

class OpenSubtitlesApi(
    private val client: OkHttpClient,
    private val logger: ExoBoostLogger,
) {
    companion object {
        private const val TAG = "OpenSubtitlesApi"
        private const val BASE_URL = "https://api.opensubtitles.com/api/v1"
        private const val USER_AGENT = "ExoBoost"

        private const val API_KEY = "YOUR_API_KEY_HERE"
    }

    suspend fun searchSubtitles(query: SubtitleQuery): List<SubtitleTrack> =
        withContext(Dispatchers.IO) {
            try {
                logger.debug(TAG, "Searching subtitles for: ${query.videoName}")

                val urlBuilder = StringBuilder("$BASE_URL/subtitles?")
                urlBuilder.append("query=${query.videoName.replace(" ", "+")}")
                urlBuilder.append("&languages=${query.language}")

                query.imdbId?.let { urlBuilder.append("&imdb_id=$it") }
                query.season?.let { urlBuilder.append("&season_number=$it") }
                query.episode?.let { urlBuilder.append("&episode_number=$it") }

                val request =
                    Request
                        .Builder()
                        .url(urlBuilder.toString())
                        .header("Api-Key", API_KEY)
                        .header("User-Agent", USER_AGENT)
                        .build()

                val response = client.newCall(request).execute()

                if (!response.isSuccessful) {
                    logger.warning(TAG, "OpenSubtitles API error: ${response.code}")
                    return@withContext emptyList()
                }

                val jsonResponse = response.body?.string() ?: return@withContext emptyList()
                parseSearchResults(jsonResponse)
            } catch (e: Exception) {
                logger.error(TAG, "Error searching OpenSubtitles", e)
                emptyList()
            }
        }

    private fun parseSearchResults(json: String): List<SubtitleTrack> {
        val tracks = mutableListOf<SubtitleTrack>()

        try {
            val jsonObject = JSONObject(json)
            val dataArray = jsonObject.optJSONArray("data") ?: return emptyList()

            for (i in 0 until dataArray.length()) {
                val item = dataArray.getJSONObject(i)
                val attributes = item.optJSONObject("attributes") ?: continue

                val files = attributes.optJSONArray("files") ?: continue
                if (files.length() == 0) continue

                val fileInfo = files.getJSONObject(0)
                val fileId = fileInfo.optInt("file_id", 0)

                if (fileId == 0) continue

                val language = attributes.optString("language", "Unknown")
                val languageCode = language.lowercase()

                tracks.add(
                    SubtitleTrack(
                        id = "opensubtitles_$fileId",
                        language = language,
                        languageCode = languageCode,
                        url = "$BASE_URL/download/$fileId",
                        format = SubtitleFormat.SRT,
                        source = SubtitleSource.OPENSUBTITLES,
                        isDefault = false,
                        isAutoGenerated = false,
                    ),
                )
            }
        } catch (e: Exception) {
            logger.error(TAG, "Error parsing OpenSubtitles results", e)
        }

        return tracks
    }

    suspend fun downloadSubtitle(track: SubtitleTrack): String? =
        withContext(Dispatchers.IO) {
            try {
                logger.debug(TAG, "Downloading subtitle: ${track.id}")

                val request =
                    Request
                        .Builder()
                        .url(track.url)
                        .header("Api-Key", API_KEY)
                        .header("User-Agent", USER_AGENT)
                        .build()

                val response = client.newCall(request).execute()

                if (!response.isSuccessful) {
                    logger.warning(TAG, "Download failed: ${response.code}")
                    return@withContext null
                }

                response.body?.string()
            } catch (e: Exception) {
                logger.error(TAG, "Error downloading subtitle", e)
                null
            }
        }
}
